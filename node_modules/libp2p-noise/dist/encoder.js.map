{"version":3,"sources":["../src/encoder.ts"],"names":["uint16BEEncode","value","target","offset","Buffer","allocUnsafe","writeUInt16BE","bytes","uint16BEDecode","data","length","RangeError","readUInt16BE","encode0","message","concat","ne","ciphertext","encode1","ns","encode2","decode0","input","Error","slice","alloc","decode1","decode2"],"mappings":";;;;;;;;;;;;;AAAA;;AAIO,MAAMA,cAAc,GAAG,CAACC,KAAD,EAAQC,MAAR,EAAgBC,MAAhB,KAA2B;AACvDD,EAAAA,MAAM,GAAGA,MAAM,IAAIE,eAAOC,WAAP,CAAmB,CAAnB,CAAnB;AACAH,EAAAA,MAAM,CAACI,aAAP,CAAqBL,KAArB,EAA4BE,MAA5B;AACA,SAAOD,MAAP;AACD,CAJM;;;AAKPF,cAAc,CAACO,KAAf,GAAuB,CAAvB;;AAEO,MAAMC,cAAc,GAAGC,IAAI,IAAI;AACpC,MAAIA,IAAI,CAACC,MAAL,GAAc,CAAlB,EAAqB,MAAMC,UAAU,CAAC,0BAAD,CAAhB;AACrB,SAAOF,IAAI,CAACG,YAAL,CAAkB,CAAlB,CAAP;AACD,CAHM;;;AAIPJ,cAAc,CAACD,KAAf,GAAuB,CAAvB,C,CAEA;;AAEO,SAASM,OAAT,CAAiBC,OAAjB,EAAgD;AACrD,SAAOV,eAAOW,MAAP,CAAc,CAACD,OAAO,CAACE,EAAT,EAAaF,OAAO,CAACG,UAArB,CAAd,CAAP;AACD;;AAEM,SAASC,OAAT,CAAiBJ,OAAjB,EAAgD;AACrD,SAAOV,eAAOW,MAAP,CAAc,CAACD,OAAO,CAACE,EAAT,EAAaF,OAAO,CAACK,EAArB,EAAyBL,OAAO,CAACG,UAAjC,CAAd,CAAP;AACD;;AAEM,SAASG,OAAT,CAAiBN,OAAjB,EAAgD;AACrD,SAAOV,eAAOW,MAAP,CAAc,CAACD,OAAO,CAACK,EAAT,EAAaL,OAAO,CAACG,UAArB,CAAd,CAAP;AACD;;AAEM,SAASI,OAAT,CAAiBC,KAAjB,EAA8C;AACnD,MAAIA,KAAK,CAACZ,MAAN,GAAe,EAAnB,EAAuB;AACrB,UAAM,IAAIa,KAAJ,CAAU,iEAAV,CAAN;AACD;;AAED,SAAO;AACLP,IAAAA,EAAE,EAAEM,KAAK,CAACE,KAAN,CAAY,CAAZ,EAAe,EAAf,CADC;AAELP,IAAAA,UAAU,EAAEK,KAAK,CAACE,KAAN,CAAY,EAAZ,EAAgBF,KAAK,CAACZ,MAAtB,CAFP;AAGLS,IAAAA,EAAE,EAAEf,eAAOqB,KAAP,CAAa,CAAb;AAHC,GAAP;AAKD;;AAEM,SAASC,OAAT,CAAiBJ,KAAjB,EAA8C;AACnD,MAAIA,KAAK,CAACZ,MAAN,GAAe,EAAnB,EAAuB;AACrB,UAAM,IAAIa,KAAJ,CAAU,iEAAV,CAAN;AACD;;AAED,SAAO;AACLP,IAAAA,EAAE,EAAEM,KAAK,CAACE,KAAN,CAAY,CAAZ,EAAe,EAAf,CADC;AAELL,IAAAA,EAAE,EAAEG,KAAK,CAACE,KAAN,CAAY,EAAZ,EAAgB,EAAhB,CAFC;AAGLP,IAAAA,UAAU,EAAEK,KAAK,CAACE,KAAN,CAAY,EAAZ,EAAgBF,KAAK,CAACZ,MAAtB;AAHP,GAAP;AAKD;;AAEM,SAASiB,OAAT,CAAiBL,KAAjB,EAA8C;AACnD,MAAIA,KAAK,CAACZ,MAAN,GAAe,EAAnB,EAAuB;AACrB,UAAM,IAAIa,KAAJ,CAAU,iEAAV,CAAN;AACD;;AAED,SAAO;AACLP,IAAAA,EAAE,EAAEZ,eAAOqB,KAAP,CAAa,CAAb,CADC;AAELN,IAAAA,EAAE,EAAEG,KAAK,CAACE,KAAN,CAAY,CAAZ,EAAe,EAAf,CAFC;AAGLP,IAAAA,UAAU,EAAEK,KAAK,CAACE,KAAN,CAAY,EAAZ,EAAgBF,KAAK,CAACZ,MAAtB;AAHP,GAAP;AAKD","sourcesContent":["import {Buffer} from \"buffer\";\nimport {bytes} from \"./@types/basic\";\nimport {MessageBuffer} from \"./@types/handshake\";\n\nexport const uint16BEEncode = (value, target, offset) => {\n  target = target || Buffer.allocUnsafe(2);\n  target.writeUInt16BE(value, offset);\n  return target;\n};\nuint16BEEncode.bytes = 2;\n\nexport const uint16BEDecode = data => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE');\n  return data.readUInt16BE(0);\n};\nuint16BEDecode.bytes = 2;\n\n// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nexport function encode0(message: MessageBuffer): bytes {\n  return Buffer.concat([message.ne, message.ciphertext]);\n}\n\nexport function encode1(message: MessageBuffer): bytes {\n  return Buffer.concat([message.ne, message.ns, message.ciphertext]);\n}\n\nexport function encode2(message: MessageBuffer): bytes {\n  return Buffer.concat([message.ns, message.ciphertext]);\n}\n\nexport function decode0(input: bytes): MessageBuffer {\n  if (input.length < 32) {\n    throw new Error(\"Cannot decode stage 0 MessageBuffer: length less than 32 bytes.\");\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ciphertext: input.slice(32, input.length),\n    ns: Buffer.alloc(0),\n  }\n}\n\nexport function decode1(input: bytes): MessageBuffer {\n  if (input.length < 80) {\n    throw new Error(\"Cannot decode stage 1 MessageBuffer: length less than 80 bytes.\");\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ns: input.slice(32, 80),\n    ciphertext: input.slice(80, input.length),\n  }\n}\n\nexport function decode2(input: bytes): MessageBuffer {\n  if (input.length < 48) {\n    throw new Error(\"Cannot decode stage 2 MessageBuffer: length less than 48 bytes.\");\n  }\n\n  return {\n    ne: Buffer.alloc(0),\n    ns: input.slice(0, 48),\n    ciphertext: input.slice(48, input.length),\n  }\n}\n"],"file":"encoder.js"}